-- ============================================
-- Migration: Add cancellation_reason Column to Deposit Table
-- ============================================
-- Thêm cột cancellation_reason để lưu lý do hủy đơn nạp tiền

-- Lưu ý: Azure SQL Database không hỗ trợ USE statement, cần chọn database trước khi chạy
GO

-- Thêm cột cancellation_reason
IF NOT EXISTS (SELECT * FROM sys.columns WHERE object_id = OBJECT_ID(N'[dbo].[deposit]') AND name = 'cancellation_reason')
BEGIN
    ALTER TABLE deposit ADD cancellation_reason NVARCHAR(500) NULL;
    PRINT 'Column cancellation_reason added to deposit table';
END
ELSE
BEGIN
    PRINT 'Column cancellation_reason already exists in deposit table';
END
GO

PRINT 'Migration completed successfully';
GO

-- ============================================
-- Migration: Add Payment Webhook Log Table
-- ============================================
-- Tạo bảng payment_webhook_log để log mọi request từ SePay

USE printing_service_db;
GO

-- Tạo bảng payment_webhook_log
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[payment_webhook_log]') AND type in (N'U'))
BEGIN
    CREATE TABLE payment_webhook_log (
        log_id UNIQUEIDENTIFIER PRIMARY KEY DEFAULT NEWID(),
        gateway_transaction_id VARCHAR(50), -- ID của SePay (id trong payload)
        bank_reference_code VARCHAR(50),    -- Mã giao dịch ngân hàng (referenceCode)
        payload_content NVARCHAR(MAX),      -- Toàn bộ JSON body nhận được
        processed_status VARCHAR(20) CHECK (processed_status IN ('success', 'failed', 'duplicate', 'ignored', 'processing')),
        error_message NVARCHAR(MAX) NULL,
        created_at DATETIME DEFAULT GETDATE()
    );
    
    CREATE INDEX idx_webhook_gateway_id ON payment_webhook_log(gateway_transaction_id);
    CREATE INDEX idx_webhook_reference_code ON payment_webhook_log(bank_reference_code);
    CREATE INDEX idx_webhook_created_at ON payment_webhook_log(created_at);
    
    PRINT 'Table payment_webhook_log created successfully';
END
ELSE
BEGIN
    PRINT 'Table payment_webhook_log already exists';
END
GO

-- ============================================
-- Migration: Update Deposit Table
-- ============================================
-- Thêm cột expired_at và cập nhật payment_status constraint

-- Thêm cột expired_at nếu chưa tồn tại
IF NOT EXISTS (SELECT * FROM sys.columns WHERE object_id = OBJECT_ID(N'[dbo].[deposit]') AND name = 'expired_at')
BEGIN
    ALTER TABLE deposit ADD expired_at DATETIME NULL;
    PRINT 'Column expired_at added to deposit table';
END
ELSE
BEGIN
    PRINT 'Column expired_at already exists in deposit table';
END
GO

-- Tạo index cho expired_at
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'idx_deposit_expired_at' AND object_id = OBJECT_ID(N'[dbo].[deposit]'))
BEGIN
    CREATE INDEX idx_deposit_expired_at ON deposit(expired_at);
    PRINT 'Index idx_deposit_expired_at created';
END
GO

-- Tạo composite index cho query tối ưu
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'idx_deposit_student_status_expired' AND object_id = OBJECT_ID(N'[dbo].[deposit]'))
BEGIN
    CREATE INDEX idx_deposit_student_status_expired ON deposit(student_id, payment_status, expired_at);
    PRINT 'Index idx_deposit_student_status_expired created';
END
GO

-- Cập nhật constraint cho payment_status để cho phép giá trị 'expired'
-- SQL Server không hỗ trợ ALTER CHECK constraint trực tiếp, cần drop và tạo lại
DECLARE @constraintName NVARCHAR(200);
DECLARE @sql NVARCHAR(MAX);

-- Tìm tên constraint CHECK hiện tại cho payment_status
-- Tìm constraint có chứa 'pending', 'completed', 'failed', 'refunded' trong definition
SELECT @constraintName = name
FROM sys.check_constraints
WHERE parent_object_id = OBJECT_ID('deposit')
AND (
    definition LIKE '%payment_status%' 
    AND definition LIKE '%pending%'
    AND definition LIKE '%completed%'
);

-- Nếu tìm thấy constraint, drop và tạo lại
IF @constraintName IS NOT NULL
BEGIN
    SET @sql = 'ALTER TABLE deposit DROP CONSTRAINT ' + QUOTENAME(@constraintName);
    EXEC sp_executesql @sql;
    PRINT 'Dropped existing payment_status constraint: ' + @constraintName;
    
    -- Tạo lại constraint với giá trị 'expired'
    ALTER TABLE deposit 
    ADD CONSTRAINT CK_deposit_payment_status 
    CHECK (payment_status IN ('pending', 'completed', 'failed', 'refunded', 'expired'));
    
    PRINT 'Created new payment_status constraint with expired status';
END
ELSE
BEGIN
    -- Kiểm tra xem constraint mới đã tồn tại chưa (có thể đã được tạo bởi Hibernate)
    IF NOT EXISTS (
        SELECT 1 FROM sys.check_constraints 
        WHERE parent_object_id = OBJECT_ID('deposit')
        AND name = 'CK_deposit_payment_status'
    )
    BEGIN
        -- Nếu chưa có constraint, tạo mới
        ALTER TABLE deposit 
        ADD CONSTRAINT CK_deposit_payment_status 
        CHECK (payment_status IN ('pending', 'completed', 'failed', 'refunded', 'expired'));
        
        PRINT 'Created payment_status constraint with expired status';
    END
    ELSE
    BEGIN
        PRINT 'Payment_status constraint already exists with expired status';
    END
END
GO

PRINT 'Migration completed successfully';
GO

-- ============================================
-- Migration: Add deposit_code Column to Deposit Table
-- ============================================
-- Thêm cột deposit_code (8 ký tự alphanumeric, unique) để làm mã ngắn gọn cho đơn nạp tiền
-- Lưu ý: Chạy script này trong database printing_service_db
-- Azure SQL Database không hỗ trợ USE statement, cần chọn database trước khi chạy
GO

-- Thêm cột deposit_code (cho phép NULL tạm thời để backfill dữ liệu cũ)
IF NOT EXISTS (SELECT * FROM sys.columns WHERE object_id = OBJECT_ID(N'[dbo].[deposit]') AND name = 'deposit_code')
BEGIN
    ALTER TABLE deposit ADD deposit_code VARCHAR(8) NULL;
    PRINT 'Column deposit_code added to deposit table (temporary NULL allowed)';
END
ELSE
BEGIN
    PRINT 'Column deposit_code already exists in deposit table';
END
GO

-- Stored Procedure để sinh mã ngẫu nhiên 8 ký tự (A-Z, 0-9)
-- Không thể dùng RAND() trong function, nên dùng stored procedure
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GenerateDepositCode]') AND type in (N'P', N'PC'))
BEGIN
    DROP PROCEDURE [dbo].[GenerateDepositCode];
END
GO

CREATE PROCEDURE [dbo].[GenerateDepositCode]
    @code VARCHAR(8) OUTPUT
AS
BEGIN
    DECLARE @chars VARCHAR(36) = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    DECLARE @i INT = 1;
    SET @code = '';
    
    WHILE @i <= 8
    BEGIN
        -- Sử dụng CHECKSUM(NEWID()) để tạo số ngẫu nhiên
        DECLARE @randomIndex INT = ABS(CHECKSUM(NEWID())) % 36;
        SET @code = @code + SUBSTRING(@chars, @randomIndex + 1, 1);
        SET @i = @i + 1;
    END
END
GO

-- Backfill: Sinh mã cho các record hiện có (nếu có)
DECLARE @rowCount INT;
SELECT @rowCount = COUNT(*) FROM deposit WHERE deposit_code IS NULL;

IF @rowCount > 0
BEGIN
    PRINT 'Backfilling deposit_code for ' + CAST(@rowCount AS VARCHAR) + ' existing records...';
    
    DECLARE @depositId UNIQUEIDENTIFIER;
    DECLARE @newCode VARCHAR(8);
    DECLARE @exists INT;
    
    DECLARE deposit_cursor CURSOR FOR
    SELECT deposit_id FROM deposit WHERE deposit_code IS NULL;
    
    OPEN deposit_cursor;
    FETCH NEXT FROM deposit_cursor INTO @depositId;
    
    WHILE @@FETCH_STATUS = 0
    BEGIN
        -- Sinh mã mới và kiểm tra unique
        EXEC [dbo].[GenerateDepositCode] @code = @newCode OUTPUT;
        SET @exists = (SELECT COUNT(*) FROM deposit WHERE deposit_code = @newCode);
        
        -- Retry nếu trùng (tối đa 10 lần)
        DECLARE @retryCount INT = 0;
        WHILE @exists > 0 AND @retryCount < 10
        BEGIN
            EXEC [dbo].[GenerateDepositCode] @code = @newCode OUTPUT;
            SET @exists = (SELECT COUNT(*) FROM deposit WHERE deposit_code = @newCode);
            SET @retryCount = @retryCount + 1;
        END
        
        -- Cập nhật deposit_code
        UPDATE deposit SET deposit_code = @newCode WHERE deposit_id = @depositId;
        
        FETCH NEXT FROM deposit_cursor INTO @depositId;
    END
    
    CLOSE deposit_cursor;
    DEALLOCATE deposit_cursor;
    
    PRINT 'Backfill completed';
END
ELSE
BEGIN
    PRINT 'No existing records to backfill';
END
GO

-- Kiểm tra xem còn NULL values không trước khi thêm constraint
DECLARE @nullCount INT;
SELECT @nullCount = COUNT(*) FROM deposit WHERE deposit_code IS NULL;

IF @nullCount > 0
BEGIN
    PRINT 'ERROR: Still have ' + CAST(@nullCount AS VARCHAR) + ' records with NULL deposit_code. Cannot proceed with NOT NULL constraint.';
    RAISERROR('Migration failed: NULL values still exist', 16, 1);
END
ELSE
BEGIN
    PRINT 'All records have deposit_code. Proceeding with constraints...';
    
    -- Thêm constraint NOT NULL và UNIQUE
    -- Bước 1: Kiểm tra và drop constraint cũ nếu có
    IF EXISTS (SELECT * FROM sys.check_constraints WHERE parent_object_id = OBJECT_ID('deposit') AND name = 'CK_deposit_deposit_code_not_null')
    BEGIN
        ALTER TABLE deposit DROP CONSTRAINT CK_deposit_deposit_code_not_null;
        PRINT 'Dropped existing NOT NULL constraint';
    END
    
    IF EXISTS (SELECT * FROM sys.indexes WHERE name = 'UQ_deposit_deposit_code' AND object_id = OBJECT_ID('deposit'))
    BEGIN
        DROP INDEX UQ_deposit_deposit_code ON deposit;
        PRINT 'Dropped existing UNIQUE index';
    END
    
    -- Bước 2: Thay đổi cột thành NOT NULL (ALTER COLUMN)
    ALTER TABLE deposit 
    ALTER COLUMN deposit_code VARCHAR(8) NOT NULL;
    PRINT 'Changed deposit_code column to NOT NULL';
    
    -- Bước 3: Tạo UNIQUE index
    CREATE UNIQUE INDEX UQ_deposit_deposit_code ON deposit(deposit_code);
    PRINT 'Created UNIQUE index for deposit_code';
END
GO

-- Bước 4: Tạo index thông thường để tối ưu query
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'idx_deposit_code' AND object_id = OBJECT_ID(N'[dbo].[deposit]'))
BEGIN
    CREATE INDEX idx_deposit_code ON deposit(deposit_code);
    PRINT 'Created index idx_deposit_code';
END
GO

-- Xóa stored procedure tạm thời (không cần thiết sau khi backfill)
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GenerateDepositCode]') AND type in (N'P', N'PC'))
BEGIN
    DROP PROCEDURE [dbo].[GenerateDepositCode];
    PRINT 'Dropped temporary stored procedure GenerateDepositCode';
END
GO

PRINT 'Migration completed successfully';
GO

